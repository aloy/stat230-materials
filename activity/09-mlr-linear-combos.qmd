---
title: "Including Categorical Predictors"
webr:
  packages:
    - ggeffects
    - ggformula
format: 
  live-html:
    toc: true
engine: knitr
editor: source
editor_options: 
  chunk_output_type: console
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}

```{r}
#| include: false
p <- 0
```


## Overview

In this activity you will learn how to include build multiple regression models in R, including models with categorical predictors. The `cars` data set loaded below contains information on used cars for sale, including their `Price`, `Mileage`, and `Make` (a categorical variable with six levels).
 
```{webr}
cars <- read.csv("https://aloy.github.io/stat230-materials/data/Cars.csv", stringsAsFactors = TRUE)
```

## Thinking about the data

To begin, create a scatterplot of `Price` versus `Mileage`. 

```{webr}
#| min-lines: 3
# put your code here
```

**Q`r (p <- p + 1)`.** What do you notice about the relationship between these two variables? Is a transformation necessary?

**Q`r (p <- p + 1)`.** The `Make` variable is categorical with six levels: Buick, Cadillac, Chevrolet, Pontiac, SAAB, and Saturn. To include this variable in a regression model, we need use indicator (i.e., dummy) variables. How many do we need to make?



## Fitting an MLR model

Build (fit) a multiple regression model using `log(Price)` as the response with `Mileage` and `Make` as the predictor variables. To do this, you use `+` to separate the predictor variable on the right side of the `~` in the model formula. R will automatically convert a categorical explanatory variable into a set of indicator variables. 

```{webr}
# Fill in the blanks to fit the MLR model
car_lm <- lm(___ ~ ___ + ___, data = ___)
summary(car_lm)
```

**Q`r (p <- p + 1)`.** Report the fitted regression equation and the $R^2$ value. 

**Q`r (p <- p + 1)`.**Which level of `Make` is the baseline? The baseline level is represented by 0's across all of the indicator variables and won't have a coefficient in the output.


**Q`r (p <- p + 1)`.**What strategy did R use to create the indicator variables for `Make`? In other words, how did R decide which level of `Make` to use as the baseline?


**Q`r (p <- p + 1)`.** Which of the following models best describes the one just fit: parallel lines, different slopes, or separate lines?


## Plotting the fitted model

To plot a fitted regression model, we can use the `ggpredict()` and `plot()` functions in the {ggeffects} package. The `ggpredict()` function creates a data frame of predicted values from the model for each `Make` across a range of `Mileage` values. The `plot()` function then creates a plot of these predicted values.

```{webr}
# Be sure to load ggeffects!
library(ggeffects)

# First, make predictions from the model
# Fill in the blank with your model name
cars_pred <- ggpredict(___, terms = ~Mileage + Make)

# Now plot the predictions
plot(cars_pred)
```

**Q`r (p <- p + 1)`.** Does this plot confirm your answer to the previous question?

:::{.callout-note}
# Tips on plotting the model

## Holding other variables at "typical" values
If you have more predictor variables in your model, then variables not specified in the `terms` argument the `ggpredict()` function are set to a specific value. Quantitative variables are set to their mean. Categorical variables are set to the mode (the level with the most observations).

## Labels
If you need to adjust your axis labels or title, then you will need to add a `labs()` layer to your plot. For example,

```{r}
#| eval: false
plot(cars_pred) +
  labs(x = "My new x label", y = "My new y label",
       title = "My new title")
```

:::



## Fitting a model with interactions

If we believe that the association between `Price` and `Mileage` differs by `Make`, then we can include an interaction term in our model. To do this, we use `*` instead of `+` to separate the predictor variables on the right side of the `~` in the model formula. This will include both main effects and the interaction term.

```{webr}
# Fill in the blanks to fit the MLR model with interaction
car_lm2 <- lm(___ ~ ___ * ___, data = ___)
summary(car_lm2)
```

**Q`r (p <- p + 1)`.** Report the fitted regression equation for Buicks and Cadillacs.

**Q`r (p <- p + 1)`.** What is the $R^2$ value for this model? Does this model appear to fit the data better than the previous model?


## Plotting the fitted model with interactions

To plot the interaction model, we again use the `ggpredict()` and `plot()` functions in the {ggeffects} package.

```{webr}
# Fill in the blank with your model name
cars_pred2 <- ggpredict(___, terms = ~Mileage + Make)

# Now plot the predictions
plot(cars_pred2)
```




## Calculating CIs for linear combinations

To calculate a confidence interval for a linear combination of coefficients, we must first calculate the estimate and standard error of the linear combination. 

Let's calculate a 95% confidence interval for the slope of the Cadillac model. Refer to your notes/slides and determine the formulas for the estimate and standard error of this slope.

Now that you know the formulas, you'll use R to implement them.  First, extract the coefficients and covariance matrix from the model object. Try printing the results to see what they look like and make note of where the Cadillac coefficients are located.

```{webr}
car_coefs <- coef(car_lm2) #<1>
car_vcov <- vcov(car_lm2)  #<2>
```

1. Extract the coefficients from the model object and store them in `car_coefs`.
2. Extract the covariance matrix from the model object and store it in `car_vcov`.

Next, calculate the estimate of the slope for Cadillacs.

```{webr}
estimate <- car_coefs[2] + car_coefs[8] #<3>
estimate
```

3. `car_coefs` is a vector, so we pull off the necessary coefficients using their position in square brackets. Here, `car_coefs[2]` pulls off the coefficient for `Mileage` and `car_coefs[8]` pulls off the coefficient for the interaction term `Mileage:MakeCadillac`. 

Now, calculate the standard error of the slope for Cadillacs. 

```{webr}
se <- sqrt(car_vcov[2,2] + car_vcov[8,8] + 2*car_vcov[2,8]) #<4>
se
```

4. `car_vcov` is a matrix, so we pull off the necessary variances and covariances using their row and column positions in square brackets. Here, `car_vcov[2,2]` pulls off the variance for `Mileage`, `car_vcov[8,8]` pulls off the variance for the interaction term `Mileage:MakeCadillac`, and `car_vcov[2,8]` pulls off the covariance between these two coefficients.

Finally, use the estimate and standard error to calculate a 95% confidence interval for the slope of the Cadillac model. You can use the `qt()` function to find the appropriate critical value.

**Q`r (p <- p + 1)`.** Calculate a 95% confidence interval for the slope of the Cadillac model.

```{webr}
#| min-lines: 3
# Calculate the 95% CI here
```


## Calculating extra sums of squares F-tests

Do we really need the interaction terms? To answer this question, we can use an extra sums of squares F-test to compare the model with interaction terms to the model without interaction terms.

We have already seen how to use the `anova()` function to compare two nested models. Here, we will use it again to compare our two car models.

```{webr}
# Fill in the blanks to run the extra sums of squares F-test
anova(___, ___)
```

### Using only the full model

We can also calculate the extra sums of squares F-test using only the full model. To do this, we need to extract the SSE and degrees of freedom for both models from the ANOVA table for the full model. 

**Q`r (p <- p + 1)`.** Run the below code and verify that the df, sums of squares, mean squares, F value, and p-value match what you got from the previous `anova()` command.

```{webr}
anova(car_lm2)
```




***

## Function quick reference

The following table summarizes the functions we learned today:

| Function | Purpose |
|----|-----------|
| `lm()` | Fit a linear model |
| `summary()` | Display detailed results from a fitted model |
| `coef()` | Extract model coefficients |
| `vcov()` | Extract the variance-covariance matrix of model coefficients |
| `ggpredict()` | Create a data frame of predicted values from a fitted model |
| `plot()` | Create a plot of predicted values from a fitted model |
| `anova()` | Create an ANOVA table for a fitted model or compare two nested models |

